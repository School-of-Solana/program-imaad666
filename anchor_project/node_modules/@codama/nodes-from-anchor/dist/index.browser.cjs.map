{"version":3,"sources":["../src/index.ts","../src/defaultVisitor.ts","../src/v00/AccountNode.ts","../src/discriminators.ts","../src/utils.ts","../src/v00/typeNodes/ArrayTypeNode.ts","../src/v00/typeNodes/TypeNode.ts","../src/v00/typeNodes/EnumTypeNode.ts","../src/v00/typeNodes/EnumEmptyVariantTypeNode.ts","../src/v00/typeNodes/EnumStructVariantTypeNode.ts","../src/v00/typeNodes/StructTypeNode.ts","../src/v00/typeNodes/StructFieldTypeNode.ts","../src/v00/typeNodes/EnumTupleVariantTypeNode.ts","../src/v00/typeNodes/TupleTypeNode.ts","../src/v00/typeNodes/MapTypeNode.ts","../src/v00/typeNodes/OptionTypeNode.ts","../src/v00/typeNodes/SetTypeNode.ts","../src/v00/DefinedTypeNode.ts","../src/v00/ErrorNode.ts","../src/v00/InstructionAccountNode.ts","../src/v00/InstructionArgumentNode.ts","../src/v00/InstructionNode.ts","../src/v00/PdaNode.ts","../src/v00/ProgramNode.ts","../src/v00/RootNode.ts","../src/v01/AccountNode.ts","../src/v01/typeNodes/ArrayTypeNode.ts","../src/v01/typeNodes/TypeNode.ts","../src/v01/unwrapGenerics.ts","../src/v01/typeNodes/EnumTypeNode.ts","../src/v01/typeNodes/EnumEmptyVariantTypeNode.ts","../src/v01/typeNodes/EnumStructVariantTypeNode.ts","../src/v01/typeNodes/StructTypeNode.ts","../src/v01/typeNodes/StructFieldTypeNode.ts","../src/v01/typeNodes/EnumTupleVariantTypeNode.ts","../src/v01/typeNodes/TupleTypeNode.ts","../src/v01/typeNodes/OptionTypeNode.ts","../src/v01/DefinedTypeNode.ts","../src/v01/ErrorNode.ts","../src/v01/InstructionAccountNode.ts","../src/v01/InstructionArgumentNode.ts","../src/v01/InstructionNode.ts","../src/v01/ProgramNode.ts","../src/v01/RootNode.ts"],"sourcesContent":["import { RootNode } from '@codama/nodes';\nimport { visit } from '@codama/visitors';\n\nimport { defaultVisitor } from './defaultVisitor';\nimport { IdlV00, rootNodeFromAnchorV00 } from './v00';\nimport { IdlV01, rootNodeFromAnchorV01 } from './v01';\n\nexport * from './defaultVisitor';\nexport * from './discriminators';\nexport * from './v00';\nexport * from './v01';\n\nexport type AnchorIdl = IdlV00 | IdlV01;\n\nexport function rootNodeFromAnchor(idl: AnchorIdl): RootNode {\n    return visit(rootNodeFromAnchorWithoutDefaultVisitor(idl), defaultVisitor());\n}\n\nexport function rootNodeFromAnchorWithoutDefaultVisitor(idl: AnchorIdl): RootNode {\n    if ((idl.metadata as { spec?: string })?.spec === '0.1.0') {\n        return rootNodeFromAnchorV01(idl as IdlV01);\n    }\n\n    return rootNodeFromAnchorV00(idl as IdlV00);\n}\n","import { assertIsNode, Node, RootNode } from '@codama/nodes';\nimport {\n    deduplicateIdenticalDefinedTypesVisitor,\n    flattenInstructionDataArgumentsVisitor,\n    getCommonInstructionAccountDefaultRules,\n    rootNodeVisitor,\n    setFixedAccountSizesVisitor,\n    setInstructionAccountDefaultValuesVisitor,\n    transformU8ArraysToBytesVisitor,\n    unwrapInstructionArgsDefinedTypesVisitor,\n    visit,\n    Visitor,\n} from '@codama/visitors';\n\nexport function defaultVisitor() {\n    return rootNodeVisitor(currentRoot => {\n        let root: RootNode = currentRoot;\n        const updateRoot = (visitor: Visitor<Node | null, 'rootNode'>) => {\n            const newRoot = visit(root, visitor);\n            assertIsNode(newRoot, 'rootNode');\n            root = newRoot;\n        };\n\n        // Defined types.\n        updateRoot(deduplicateIdenticalDefinedTypesVisitor());\n\n        // Accounts.\n        updateRoot(setFixedAccountSizesVisitor());\n\n        // Instructions.\n        updateRoot(setInstructionAccountDefaultValuesVisitor(getCommonInstructionAccountDefaultRules()));\n        updateRoot(unwrapInstructionArgsDefinedTypesVisitor());\n        updateRoot(flattenInstructionDataArgumentsVisitor());\n\n        // Extras.\n        updateRoot(transformU8ArraysToBytesVisitor());\n\n        return root;\n    });\n}\n","import {\n    AccountNode,\n    accountNode,\n    assertIsNode,\n    bytesTypeNode,\n    camelCase,\n    DiscriminatorNode,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    pdaLinkNode,\n    structFieldTypeNode,\n    StructTypeNode,\n    structTypeNode,\n} from '@codama/nodes';\n\nimport { getAnchorAccountDiscriminatorV00 } from '../discriminators';\nimport { IdlV00AccountDef } from './idl';\nimport { structTypeNodeFromAnchorV00 } from './typeNodes';\n\nexport function accountNodeFromAnchorV00(\n    idl: IdlV00AccountDef,\n    origin?: 'anchor' | 'shank',\n): AccountNode<StructTypeNode> {\n    const idlName = idl.name ?? '';\n    const name = camelCase(idlName);\n    const idlStruct = idl.type ?? { fields: [], kind: 'struct' };\n    let data = structTypeNodeFromAnchorV00(idlStruct);\n    assertIsNode(data, 'structTypeNode');\n    const hasSeeds = (idl.seeds ?? []).length > 0;\n\n    // Account discriminator.\n    let discriminators: DiscriminatorNode[] | undefined;\n    if (origin === 'anchor') {\n        const discriminator = structFieldTypeNode({\n            defaultValue: getAnchorAccountDiscriminatorV00(idlName),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: fixedSizeTypeNode(bytesTypeNode(), 8),\n        });\n        data = structTypeNode([discriminator, ...data.fields]);\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    }\n\n    return accountNode({\n        data,\n        discriminators,\n        docs: idl.docs ?? [],\n        name,\n        pda: hasSeeds ? pdaLinkNode(name) : undefined,\n        size: idl.size,\n    });\n}\n","import { BytesValueNode, bytesValueNode, pascalCase, snakeCase } from '@codama/nodes';\nimport { sha256 } from '@noble/hashes/sha2';\n\nimport { hex } from './utils';\n\nexport const getAnchorDiscriminatorV01 = (discriminator: number[]): BytesValueNode => {\n    return bytesValueNode('base16', hex(new Uint8Array(discriminator)));\n};\n\nexport const getAnchorInstructionDiscriminatorV00 = (idlName: string): BytesValueNode => {\n    const hash = sha256(`global:${snakeCase(idlName)}`).slice(0, 8);\n    return bytesValueNode('base16', hex(hash));\n};\n\nexport const getAnchorAccountDiscriminatorV00 = (idlName: string): BytesValueNode => {\n    const hash = sha256(`account:${pascalCase(idlName)}`).slice(0, 8);\n    return bytesValueNode('base16', hex(hash));\n};\n","export function hex(bytes: number[] | Uint8Array): string {\n    return (bytes as number[]).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import {\n    ArrayTypeNode,\n    arrayTypeNode,\n    fixedCountNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeArray, IdlV00TypeVec } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function arrayTypeNodeFromAnchorV00(idl: IdlV00TypeArray | IdlV00TypeVec): ArrayTypeNode {\n    if ('array' in idl) {\n        const item = typeNodeFromAnchorV00(idl.array[0]);\n        return arrayTypeNode(item, fixedCountNode(idl.array[1]));\n    }\n    const item = typeNodeFromAnchorV00(idl.vec);\n    if (idl.size === 'remainder') return arrayTypeNode(item, remainderCountNode());\n    return arrayTypeNode(item, prefixedCountNode(numberTypeNode(idl.size ?? 'u32')));\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport {\n    booleanTypeNode,\n    bytesTypeNode,\n    definedTypeLinkNode,\n    numberTypeNode,\n    publicKeyTypeNode,\n    sizePrefixTypeNode,\n    stringTypeNode,\n    TypeNode,\n} from '@codama/nodes';\n\nimport { IdlV00Type, IdlV00TypeDefTy, IdlV00TypeMap, IdlV00TypeSet } from '../idl';\nimport { arrayTypeNodeFromAnchorV00 } from './ArrayTypeNode';\nimport { enumTypeNodeFromAnchorV00 } from './EnumTypeNode';\nimport { mapTypeNodeFromAnchorV00 } from './MapTypeNode';\nimport { optionTypeNodeFromAnchorV00 } from './OptionTypeNode';\nimport { setTypeNodeFromAnchorV00 } from './SetTypeNode';\nimport { structTypeNodeFromAnchorV00 } from './StructTypeNode';\nimport { tupleTypeNodeFromAnchorV00 } from './TupleTypeNode';\n\nconst IDL_V00_TYPE_LEAVES = [\n    'string',\n    'publicKey',\n    'bytes',\n    'bool',\n    'u8',\n    'u16',\n    'u32',\n    'u64',\n    'u128',\n    'i8',\n    'i16',\n    'i32',\n    'i64',\n    'i128',\n    'f32',\n    'f64',\n    'shortU16',\n] as const;\n\nexport const typeNodeFromAnchorV00 = (idlType: IdlV00Type | IdlV00TypeDefTy): TypeNode => {\n    // Leaf.\n    if (typeof idlType === 'string' && IDL_V00_TYPE_LEAVES.includes(idlType)) {\n        if (idlType === 'bool') return booleanTypeNode();\n        if (idlType === 'publicKey') return publicKeyTypeNode();\n        if (idlType === 'string') return sizePrefixTypeNode(stringTypeNode('utf8'), numberTypeNode('u32'));\n        if (idlType === 'bytes') return sizePrefixTypeNode(bytesTypeNode(), numberTypeNode('u32'));\n        return numberTypeNode(idlType);\n    }\n\n    // Ensure eveything else is an object.\n    if (typeof idlType !== 'object') {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idlType),\n        });\n    }\n\n    // Array.\n    if ('array' in idlType && isArrayOfSize(idlType.array, 2)) {\n        return arrayTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Vec.\n    if ('vec' in idlType) {\n        return arrayTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Defined link.\n    if ('defined' in idlType && typeof idlType.defined === 'string') {\n        return definedTypeLinkNode(idlType.defined);\n    }\n\n    // Enum.\n    if ('kind' in idlType && idlType.kind === 'enum' && 'variants' in idlType) {\n        return enumTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Alias.\n    if ('kind' in idlType && idlType.kind === 'alias' && 'value' in idlType) {\n        return typeNodeFromAnchorV00(idlType.value);\n    }\n\n    // Map.\n    if (\n        ('hashMap' in idlType && isArrayOfSize(idlType.hashMap, 2)) ||\n        ('bTreeMap' in idlType && isArrayOfSize(idlType.bTreeMap, 2))\n    ) {\n        return mapTypeNodeFromAnchorV00(idlType as IdlV00TypeMap);\n    }\n\n    // Option.\n    if ('option' in idlType || 'coption' in idlType) {\n        return optionTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Set.\n    if ('hashSet' in idlType || 'bTreeSet' in idlType) {\n        return setTypeNodeFromAnchorV00(idlType as IdlV00TypeSet);\n    }\n\n    // Struct.\n    if ('kind' in idlType && 'fields' in idlType && idlType.kind === 'struct') {\n        return structTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Tuple.\n    if ('tuple' in idlType && Array.isArray(idlType.tuple)) {\n        return tupleTypeNodeFromAnchorV00(idlType);\n    }\n\n    throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n        idlType: JSON.stringify(idlType),\n    });\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isArrayOfSize(array: any, size: number): boolean {\n    return Array.isArray(array) && array.length === size;\n}\n","import { EnumTypeNode, enumTypeNode, EnumVariantTypeNode, NumberTypeNode, numberTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsNamed, IdlV00EnumFieldsTuple, IdlV00EnumVariant, IdlV00TypeDefTyEnum } from '../idl';\nimport { enumEmptyVariantTypeNodeFromAnchorV00 } from './EnumEmptyVariantTypeNode';\nimport { enumStructVariantTypeNodeFromAnchorV00 } from './EnumStructVariantTypeNode';\nimport { enumTupleVariantTypeNodeFromAnchorV00 } from './EnumTupleVariantTypeNode';\n\nexport function enumTypeNodeFromAnchorV00(\n    idl: IdlV00TypeDefTyEnum,\n): EnumTypeNode<EnumVariantTypeNode[], NumberTypeNode> {\n    const variants = idl.variants.map((variant): EnumVariantTypeNode => {\n        if (!variant.fields || variant.fields.length <= 0) {\n            return enumEmptyVariantTypeNodeFromAnchorV00(variant);\n        }\n        if (isStructVariant(variant)) {\n            return enumStructVariantTypeNodeFromAnchorV00(variant);\n        }\n        return enumTupleVariantTypeNodeFromAnchorV00(variant as IdlV00EnumVariant & { fields: IdlV00EnumFieldsTuple });\n    });\n    return enumTypeNode(variants, {\n        size: idl.size ? numberTypeNode(idl.size) : undefined,\n    });\n}\n\nfunction isStructVariant(variant: IdlV00EnumVariant): variant is IdlV00EnumVariant & { fields: IdlV00EnumFieldsNamed } {\n    const field = variant.fields![0];\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumEmptyVariantTypeNode, enumEmptyVariantTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumVariant } from '../idl';\n\nexport function enumEmptyVariantTypeNodeFromAnchorV00(idl: IdlV00EnumVariant): EnumEmptyVariantTypeNode {\n    return enumEmptyVariantTypeNode(idl.name ?? '');\n}\n","import { EnumStructVariantTypeNode, enumStructVariantTypeNode, StructTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsNamed, IdlV00EnumVariant } from '../idl';\nimport { structTypeNodeFromAnchorV00 } from './StructTypeNode';\n\nexport function enumStructVariantTypeNodeFromAnchorV00(\n    idl: IdlV00EnumVariant & { fields: IdlV00EnumFieldsNamed },\n): EnumStructVariantTypeNode<StructTypeNode> {\n    return enumStructVariantTypeNode(\n        idl.name ?? '',\n        structTypeNodeFromAnchorV00({ fields: idl.fields, kind: 'struct' }),\n    );\n}\n","import { StructTypeNode, structTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeDefTyStruct } from '../idl';\nimport { structFieldTypeNodeFromAnchorV00 } from './StructFieldTypeNode';\n\nexport function structTypeNodeFromAnchorV00(idl: IdlV00TypeDefTyStruct): StructTypeNode {\n    return structTypeNode((idl.fields ?? []).map(structFieldTypeNodeFromAnchorV00));\n}\n","import { StructFieldTypeNode, structFieldTypeNode } from '@codama/nodes';\n\nimport { IdlV00Field } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function structFieldTypeNodeFromAnchorV00(idl: IdlV00Field): StructFieldTypeNode {\n    return structFieldTypeNode({\n        docs: idl.docs ?? [],\n        name: idl.name ?? '',\n        type: typeNodeFromAnchorV00(idl.type),\n    });\n}\n","import { EnumTupleVariantTypeNode, enumTupleVariantTypeNode, TupleTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsTuple, IdlV00EnumVariant } from '../idl';\nimport { tupleTypeNodeFromAnchorV00 } from './TupleTypeNode';\n\nexport function enumTupleVariantTypeNodeFromAnchorV00(\n    idl: IdlV00EnumVariant & { fields: IdlV00EnumFieldsTuple },\n): EnumTupleVariantTypeNode<TupleTypeNode> {\n    return enumTupleVariantTypeNode(idl.name ?? '', tupleTypeNodeFromAnchorV00({ tuple: idl.fields }));\n}\n","import { TupleTypeNode, tupleTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeTuple } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function tupleTypeNodeFromAnchorV00(idl: IdlV00TypeTuple): TupleTypeNode {\n    return tupleTypeNode(idl.tuple.map(typeNodeFromAnchorV00));\n}\n","import {\n    CountNode,\n    fixedCountNode,\n    MapTypeNode,\n    mapTypeNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeMap } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function mapTypeNodeFromAnchorV00(idl: IdlV00TypeMap): MapTypeNode {\n    const [key, value] = 'hashMap' in idl ? idl.hashMap : idl.bTreeMap;\n    let size: CountNode | undefined;\n    if (idl.size === 'remainder') {\n        size = remainderCountNode();\n    } else if (typeof idl.size === 'number') {\n        size = fixedCountNode(idl.size);\n    } else {\n        size = prefixedCountNode(numberTypeNode(idl.size ?? 'u32'));\n    }\n    return mapTypeNode(typeNodeFromAnchorV00(key), typeNodeFromAnchorV00(value), size);\n}\n","import { numberTypeNode, OptionTypeNode, optionTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeOption } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function optionTypeNodeFromAnchorV00(idl: IdlV00TypeOption): OptionTypeNode {\n    const item = 'option' in idl ? idl.option : idl.coption;\n    const defaultPrefix = numberTypeNode('option' in idl ? 'u8' : 'u32');\n    const defaultFixed = !('option' in idl);\n    return optionTypeNode(typeNodeFromAnchorV00(item), {\n        fixed: idl.fixed !== undefined ? idl.fixed : defaultFixed,\n        prefix: idl.prefix ? numberTypeNode(idl.prefix) : defaultPrefix,\n    });\n}\n","import {\n    fixedCountNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n    SetTypeNode,\n    setTypeNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeSet } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function setTypeNodeFromAnchorV00(idl: IdlV00TypeSet): SetTypeNode {\n    const child = 'hashSet' in idl ? idl.hashSet : idl.bTreeSet;\n    let size: SetTypeNode['count'] | undefined;\n    if (idl.size === 'remainder') {\n        size = remainderCountNode();\n    } else if (typeof idl.size === 'number') {\n        size = fixedCountNode(idl.size);\n    } else {\n        size = prefixedCountNode(numberTypeNode(idl.size ?? 'u32'));\n    }\n    return setTypeNode(typeNodeFromAnchorV00(child), size);\n}\n","import { DefinedTypeNode, definedTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeDef } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function definedTypeNodeFromAnchorV00(idl: Partial<IdlV00TypeDef>): DefinedTypeNode {\n    const name = idl.name ?? '';\n    const idlType = idl.type ?? { fields: [], kind: 'struct' };\n    const type = typeNodeFromAnchorV00(idlType);\n    return definedTypeNode({ docs: idl.docs, name, type });\n}\n","import { ErrorNode, errorNode } from '@codama/nodes';\n\nimport { IdlV00ErrorCode } from './idl';\n\nexport function errorNodeFromAnchorV00(idl: Partial<IdlV00ErrorCode>): ErrorNode {\n    const name = idl.name ?? '';\n    const msg = idl.msg ?? '';\n    return errorNode({\n        code: idl.code ?? -1,\n        docs: idl.docs ?? [msg ? `${name}: ${msg}` : `${name}`],\n        message: msg,\n        name,\n    });\n}\n","import { InstructionAccountNode, instructionAccountNode } from '@codama/nodes';\n\nimport { IdlV00Account, IdlV00AccountItem } from './idl';\n\nexport function instructionAccountNodesFromAnchorV00(idl: IdlV00AccountItem[]): InstructionAccountNode[] {\n    return idl.flatMap(account =>\n        'accounts' in account\n            ? instructionAccountNodesFromAnchorV00(account.accounts)\n            : [instructionAccountNodeFromAnchorV00(account)],\n    );\n}\n\nexport function instructionAccountNodeFromAnchorV00(idl: IdlV00Account): InstructionAccountNode {\n    const isOptional = idl.optional ?? idl.isOptional ?? false;\n    const desc = idl.desc ? [idl.desc] : undefined;\n    return instructionAccountNode({\n        docs: idl.docs ?? desc ?? [],\n        isOptional,\n        isSigner: idl.isOptionalSigner ? 'either' : (idl.isSigner ?? false),\n        isWritable: idl.isMut ?? false,\n        name: idl.name ?? '',\n    });\n}\n","import { InstructionArgumentNode, instructionArgumentNode } from '@codama/nodes';\n\nimport { IdlV00Field } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function instructionArgumentNodeFromAnchorV00(idl: IdlV00Field): InstructionArgumentNode {\n    return instructionArgumentNode({\n        docs: idl.docs ?? [],\n        name: idl.name ?? '',\n        type: typeNodeFromAnchorV00(idl.type),\n    });\n}\n","import {\n    bytesTypeNode,\n    bytesValueNode,\n    camelCase,\n    DiscriminatorNode,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    instructionArgumentNode,\n    InstructionNode,\n    instructionNode,\n    numberValueNode,\n} from '@codama/nodes';\n\nimport { getAnchorInstructionDiscriminatorV00 } from '../discriminators';\nimport { IdlV00Instruction } from './idl';\nimport { instructionAccountNodesFromAnchorV00 } from './InstructionAccountNode';\nimport { instructionArgumentNodeFromAnchorV00 } from './InstructionArgumentNode';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function instructionNodeFromAnchorV00(\n    idl: IdlV00Instruction,\n    ixIndex: number,\n    origin?: 'anchor' | 'shank',\n): InstructionNode {\n    const idlName = idl.name ?? '';\n    const name = camelCase(idlName);\n    let dataArguments = (idl.args ?? []).map(instructionArgumentNodeFromAnchorV00);\n\n    // Instruction discriminator.\n    let discriminators: DiscriminatorNode[] | undefined;\n    if (idl.discriminant) {\n        const discriminatorField = instructionArgumentNode({\n            defaultValue: numberValueNode(idl.discriminant.value),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: typeNodeFromAnchorV00(idl.discriminant.type),\n        });\n        dataArguments = [discriminatorField, ...dataArguments];\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    } else if (origin === 'anchor') {\n        const discriminatorField = instructionArgumentNode({\n            defaultValue: getAnchorInstructionDiscriminatorV00(idlName),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: fixedSizeTypeNode(bytesTypeNode(), 8),\n        });\n        dataArguments = [discriminatorField, ...dataArguments];\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    } else if (origin === 'shank') {\n        const discriminatorField = instructionArgumentNode({\n            defaultValue: bytesValueNode('base16', ixIndex.toString(16)),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: fixedSizeTypeNode(bytesTypeNode(), 1),\n        });\n        dataArguments = [discriminatorField, ...dataArguments];\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    }\n\n    return instructionNode({\n        accounts: instructionAccountNodesFromAnchorV00(idl.accounts ?? []),\n        arguments: dataArguments,\n        discriminators,\n        docs: idl.docs ?? [],\n        name,\n        optionalAccountStrategy: idl.legacyOptionalAccountsStrategy ? 'omitted' : 'programId',\n    });\n}\n","import {\n    booleanValueNode,\n    bytesTypeNode,\n    camelCase,\n    constantPdaSeedNode,\n    constantPdaSeedNodeFromProgramId,\n    numberValueNode,\n    PdaNode,\n    pdaNode,\n    PdaSeedNode,\n    stringTypeNode,\n    stringValueNode,\n    variablePdaSeedNode,\n} from '@codama/nodes';\n\nimport { IdlV00PdaDef } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function pdaNodeFromAnchorV00(idl: IdlV00PdaDef): PdaNode {\n    const name = camelCase(idl.name ?? '');\n    const seeds = (idl.seeds ?? []).map((seed): PdaSeedNode => {\n        if (seed.kind === 'constant') {\n            const type = (() => {\n                if (seed.type === 'string') return stringTypeNode('utf8');\n                if (seed.type === 'bytes') return bytesTypeNode();\n                return typeNodeFromAnchorV00(seed.type);\n            })();\n            const value = (() => {\n                if (typeof seed.value === 'string') return stringValueNode(seed.value);\n                if (typeof seed.value === 'number') return numberValueNode(seed.value);\n                return booleanValueNode(seed.value);\n            })();\n            return constantPdaSeedNode(type, value);\n        }\n        if (seed.kind === 'variable') {\n            return variablePdaSeedNode(\n                seed.name,\n                typeNodeFromAnchorV00(seed.type),\n                seed.description ? [seed.description] : [],\n            );\n        }\n        return constantPdaSeedNodeFromProgramId();\n    });\n    return pdaNode({ name, seeds });\n}\n","import { ProgramNode, programNode, ProgramVersion } from '@codama/nodes';\n\nimport { accountNodeFromAnchorV00 } from './AccountNode';\nimport { definedTypeNodeFromAnchorV00 } from './DefinedTypeNode';\nimport { errorNodeFromAnchorV00 } from './ErrorNode';\nimport { IdlV00 } from './idl';\nimport { instructionNodeFromAnchorV00 } from './InstructionNode';\nimport { pdaNodeFromAnchorV00 } from './PdaNode';\n\nexport function programNodeFromAnchorV00(idl: IdlV00): ProgramNode {\n    const origin = (idl?.metadata as { origin?: 'anchor' | 'shank' })?.origin ?? 'anchor';\n    const pdas = (idl.accounts ?? []).filter(account => (account.seeds ?? []).length > 0).map(pdaNodeFromAnchorV00);\n    const accounts = (idl.accounts ?? []).map(a => accountNodeFromAnchorV00(a, origin));\n    const instructions = (idl.instructions ?? []).map((instruction, index) =>\n        instructionNodeFromAnchorV00(instruction, index, origin),\n    );\n    return programNode({\n        accounts,\n        definedTypes: (idl?.types ?? []).map(definedTypeNodeFromAnchorV00),\n        errors: (idl?.errors ?? []).map(errorNodeFromAnchorV00),\n        instructions,\n        name: idl?.name ?? '',\n        origin,\n        pdas,\n        publicKey: (idl?.metadata as { address?: string })?.address ?? '',\n        version: idl.version as ProgramVersion,\n    });\n}\n","import { RootNode, rootNode } from '@codama/nodes';\n\nimport { IdlV00 } from './idl';\nimport { programNodeFromAnchorV00 } from './ProgramNode';\n\nexport function rootNodeFromAnchorV00(program: IdlV00, additionalPrograms: IdlV00[] = []): RootNode {\n    const programNode = programNodeFromAnchorV00(program);\n    const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV00);\n    return rootNode(programNode, additionalProgramNodes);\n}\n","import { CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, CodamaError } from '@codama/errors';\nimport {\n    AccountNode,\n    accountNode,\n    assertIsNode,\n    bytesTypeNode,\n    camelCase,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    structFieldTypeNode,\n    structTypeNode,\n} from '@codama/nodes';\n\nimport { getAnchorDiscriminatorV01 } from './../discriminators';\nimport type { IdlV01Account, IdlV01TypeDef } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\nimport type { GenericsV01 } from './unwrapGenerics';\n\nexport function accountNodeFromAnchorV01(\n    idl: IdlV01Account,\n    types: IdlV01TypeDef[],\n    generics: GenericsV01,\n): AccountNode {\n    const name = camelCase(idl.name);\n    const type = types.find(({ name }) => name === idl.name);\n\n    if (!type) {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { name: idl.name });\n    }\n\n    const data = typeNodeFromAnchorV01(type.type, generics);\n    assertIsNode(data, 'structTypeNode');\n\n    const discriminator = structFieldTypeNode({\n        defaultValue: getAnchorDiscriminatorV01(idl.discriminator),\n        defaultValueStrategy: 'omitted',\n        name: 'discriminator',\n        type: fixedSizeTypeNode(bytesTypeNode(), idl.discriminator.length),\n    });\n\n    return accountNode({\n        data: structTypeNode([discriminator, ...data.fields]),\n        discriminators: [fieldDiscriminatorNode('discriminator')],\n        name,\n    });\n}\n","import { ArrayTypeNode, arrayTypeNode, fixedCountNode, numberTypeNode, prefixedCountNode } from '@codama/nodes';\n\nimport type { IdlV01TypeArray, IdlV01TypeVec } from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function arrayTypeNodeFromAnchorV01(idl: IdlV01TypeArray | IdlV01TypeVec, generics: GenericsV01): ArrayTypeNode {\n    if ('array' in idl) {\n        const item = typeNodeFromAnchorV01(idl.array[0], generics);\n        const size =\n            typeof idl.array[1] === 'number' ? idl.array[1] : parseInt(generics.constArgs[idl.array[1].generic].value);\n        return arrayTypeNode(item, fixedCountNode(size));\n    }\n\n    const item = typeNodeFromAnchorV01(idl.vec, generics);\n\n    return arrayTypeNode(item, prefixedCountNode(numberTypeNode('u32')));\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport {\n    booleanTypeNode,\n    bytesTypeNode,\n    definedTypeLinkNode,\n    numberTypeNode,\n    publicKeyTypeNode,\n    sizePrefixTypeNode,\n    stringTypeNode,\n    TypeNode,\n} from '@codama/nodes';\n\nimport type {\n    IdlV01DefinedFields,\n    IdlV01DefinedFieldsNamed,\n    IdlV01DefinedFieldsTuple,\n    IdlV01Field,\n    IdlV01Type,\n    IdlV01TypeDefTy,\n} from '../idl';\nimport { type GenericsV01, unwrapGenericTypeFromAnchorV01 } from '../unwrapGenerics';\nimport { arrayTypeNodeFromAnchorV01 } from './ArrayTypeNode';\nimport { enumTypeNodeFromAnchorV01 } from './EnumTypeNode';\nimport { optionTypeNodeFromAnchorV01 } from './OptionTypeNode';\nimport { structTypeNodeFromAnchorV01 } from './StructTypeNode';\nimport { tupleTypeNodeFromAnchorV01 } from './TupleTypeNode';\n\nconst IDL_V01_TYPE_LEAVES = [\n    'string',\n    'pubkey',\n    'bytes',\n    'bool',\n    'u8',\n    'u16',\n    'u32',\n    'u64',\n    'u128',\n    'i8',\n    'i16',\n    'i32',\n    'i64',\n    'i128',\n    'f32',\n    'f64',\n    'shortU16',\n] as const;\n\nexport const typeNodeFromAnchorV01 = (idlType: IdlV01Type | IdlV01TypeDefTy, generics: GenericsV01): TypeNode => {\n    // Leaf.\n    if (typeof idlType === 'string' && IDL_V01_TYPE_LEAVES.includes(idlType)) {\n        if (idlType === 'bool') return booleanTypeNode();\n        if (idlType === 'pubkey') return publicKeyTypeNode();\n        if (idlType === 'string') return sizePrefixTypeNode(stringTypeNode('utf8'), numberTypeNode('u32'));\n        if (idlType === 'bytes') return sizePrefixTypeNode(bytesTypeNode(), numberTypeNode('u32'));\n        return numberTypeNode(idlType);\n    }\n\n    // Ensure eveything else is an object.\n    if (typeof idlType !== 'object') {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idlType),\n        });\n    }\n\n    // Array.\n    if ('array' in idlType && isArrayOfSize(idlType.array, 2)) {\n        return arrayTypeNodeFromAnchorV01(idlType, generics);\n    }\n\n    // Vec.\n    if ('vec' in idlType) {\n        return arrayTypeNodeFromAnchorV01(idlType, generics);\n    }\n\n    // Defined link.\n    if ('defined' in idlType && typeof idlType.defined === 'object') {\n        return 'generics' in idlType.defined\n            ? unwrapGenericTypeFromAnchorV01(idlType, generics)\n            : definedTypeLinkNode(idlType.defined.name);\n    }\n\n    // Generic reference.\n    if ('generic' in idlType) {\n        return typeNodeFromAnchorV01(generics.typeArgs[idlType.generic].type, generics);\n    }\n\n    // Enum.\n    if ('kind' in idlType && idlType.kind === 'enum' && 'variants' in idlType) {\n        return enumTypeNodeFromAnchorV01(idlType, generics);\n    }\n\n    // Alias.\n    if ('kind' in idlType && idlType.kind === 'alias' && 'value' in idlType) {\n        return typeNodeFromAnchorV01(idlType.value, generics);\n    }\n\n    // Option.\n    if ('option' in idlType) {\n        return optionTypeNodeFromAnchorV01(idlType, generics);\n    }\n\n    if ('coption' in idlType) {\n        return optionTypeNodeFromAnchorV01(idlType, generics);\n    }\n\n    // Struct and Tuple.\n    if ('kind' in idlType && idlType.kind === 'struct') {\n        const fields = idlType.fields ?? [];\n        if (isStructFieldArray(fields)) {\n            return structTypeNodeFromAnchorV01(idlType, generics);\n        }\n        if (isTupleFieldArray(fields)) {\n            return tupleTypeNodeFromAnchorV01(fields, generics);\n        }\n    }\n\n    throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n        idlType: JSON.stringify(idlType),\n    });\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isArrayOfSize(array: any, size: number): boolean {\n    return Array.isArray(array) && array.length === size;\n}\n\nfunction isStructFieldArray(field: IdlV01DefinedFields): field is IdlV01DefinedFieldsNamed {\n    return field.every(isStructField);\n}\n\nfunction isTupleFieldArray(field: IdlV01DefinedFields): field is IdlV01DefinedFieldsTuple {\n    return field.every(f => !isStructField(f));\n}\n\nfunction isStructField(field: IdlV01Field | IdlV01Type): field is IdlV01Field {\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { CODAMA_ERROR__ANCHOR__GENERIC_TYPE_MISSING, CodamaError } from '@codama/errors';\nimport { TypeNode } from '@codama/nodes';\n\nimport {\n    IdlV01GenericArgConst,\n    IdlV01GenericArgType,\n    IdlV01TypeDef,\n    IdlV01TypeDefGenericConst,\n    IdlV01TypeDefGenericType,\n    IdlV01TypeDefined,\n} from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\n\nexport type GenericsV01 = {\n    constArgs: Record<string, IdlV01GenericArgConst & IdlV01TypeDefGenericConst>;\n    typeArgs: Record<string, IdlV01GenericArgType & IdlV01TypeDefGenericType>;\n    types: Record<string, IdlV01TypeDef & Required<Pick<IdlV01TypeDef, 'generics'>>>;\n};\n\nexport function extractGenerics(types: IdlV01TypeDef[]): [IdlV01TypeDef[], GenericsV01] {\n    const [nonGenericTypes, genericTypes] = types.reduce(\n        (acc, type) => {\n            acc['generics' in type ? 1 : 0].push(type);\n            return acc;\n        },\n        [[], []] as [IdlV01TypeDef[], IdlV01TypeDef[]],\n    );\n\n    const generics = {\n        constArgs: {},\n        typeArgs: {},\n        types: Object.fromEntries(genericTypes.map(type => [type.name, type])),\n    } as GenericsV01;\n\n    return [nonGenericTypes, generics];\n}\n\nexport function unwrapGenericTypeFromAnchorV01(type: IdlV01TypeDefined, generics: GenericsV01): TypeNode {\n    const genericType = generics.types[type.defined.name];\n    if (!genericType) {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__GENERIC_TYPE_MISSING, { name: type.defined.name });\n    }\n\n    const constArgs: GenericsV01['constArgs'] = {};\n    const typeArgs: GenericsV01['typeArgs'] = {};\n\n    const genericDefinitions = genericType.generics ?? [];\n    const genericArgs = type.defined.generics ?? [];\n    genericDefinitions.forEach((genericDefinition, index) => {\n        const genericArg = genericArgs[index];\n        if (genericDefinition.kind === 'const') {\n            constArgs[genericDefinition.name] = genericArg as IdlV01GenericArgConst & IdlV01TypeDefGenericConst;\n        } else {\n            typeArgs[genericDefinition.name] = genericArg as IdlV01GenericArgType & IdlV01TypeDefGenericType;\n        }\n    });\n\n    return typeNodeFromAnchorV01(genericType.type, {\n        ...generics,\n        constArgs: { ...generics.constArgs, ...constArgs },\n        typeArgs: { ...generics.typeArgs, ...typeArgs },\n    });\n}\n","import { EnumTypeNode, enumTypeNode, EnumVariantTypeNode, NumberTypeNode } from '@codama/nodes';\n\nimport type {\n    IdlV01DefinedFieldsNamed,\n    IdlV01DefinedFieldsTuple,\n    IdlV01EnumVariant,\n    IdlV01TypeDefTyEnum,\n} from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { enumEmptyVariantTypeNodeFromAnchorV01 } from './EnumEmptyVariantTypeNode';\nimport { enumStructVariantTypeNodeFromAnchorV01 } from './EnumStructVariantTypeNode';\nimport { enumTupleVariantTypeNodeFromAnchorV01 } from './EnumTupleVariantTypeNode';\n\nexport function enumTypeNodeFromAnchorV01(\n    idl: IdlV01TypeDefTyEnum,\n    generics: GenericsV01,\n): EnumTypeNode<EnumVariantTypeNode[], NumberTypeNode> {\n    const variants = idl.variants.map((variant): EnumVariantTypeNode => {\n        if (!variant.fields || variant.fields.length <= 0) {\n            return enumEmptyVariantTypeNodeFromAnchorV01(variant);\n        }\n        if (isStructVariant(variant)) {\n            return enumStructVariantTypeNodeFromAnchorV01(variant, generics);\n        }\n        return enumTupleVariantTypeNodeFromAnchorV01(\n            variant as IdlV01EnumVariant & { fields: IdlV01DefinedFieldsTuple },\n            generics,\n        );\n    });\n    return enumTypeNode(variants);\n}\n\nfunction isStructVariant(\n    variant: IdlV01EnumVariant,\n): variant is IdlV01EnumVariant & { fields: IdlV01DefinedFieldsNamed } {\n    const field = variant.fields![0];\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumEmptyVariantTypeNode, enumEmptyVariantTypeNode } from '@codama/nodes';\n\nimport { IdlV01EnumVariant } from '../idl';\n\nexport function enumEmptyVariantTypeNodeFromAnchorV01(idl: IdlV01EnumVariant): EnumEmptyVariantTypeNode {\n    return enumEmptyVariantTypeNode(idl.name ?? '');\n}\n","import { EnumStructVariantTypeNode, enumStructVariantTypeNode, StructTypeNode } from '@codama/nodes';\n\nimport type { IdlV01DefinedFieldsNamed, IdlV01EnumVariant } from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { structTypeNodeFromAnchorV01 } from './StructTypeNode';\n\nexport function enumStructVariantTypeNodeFromAnchorV01(\n    idl: IdlV01EnumVariant & { fields: IdlV01DefinedFieldsNamed },\n    generics: GenericsV01,\n): EnumStructVariantTypeNode<StructTypeNode> {\n    return enumStructVariantTypeNode(\n        idl.name ?? '',\n        structTypeNodeFromAnchorV01({ fields: idl.fields, kind: 'struct' }, generics),\n    );\n}\n","import { StructTypeNode, structTypeNode } from '@codama/nodes';\n\nimport type { IdlV01DefinedFields, IdlV01TypeDefTyStruct } from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { structFieldTypeNodeFromAnchorV01 } from './StructFieldTypeNode';\n\nexport function structTypeNodeFromAnchorV01(idl: IdlV01TypeDefTyStruct, generics: GenericsV01): StructTypeNode {\n    const fields: IdlV01DefinedFields = idl.fields ?? [];\n\n    return structTypeNode(fields.map(field => structFieldTypeNodeFromAnchorV01(field, generics)));\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport { StructFieldTypeNode, structFieldTypeNode } from '@codama/nodes';\n\nimport type { IdlV01Field, IdlV01Type } from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function structFieldTypeNodeFromAnchorV01(\n    idl: IdlV01Field | IdlV01Type,\n    generics: GenericsV01,\n): StructFieldTypeNode {\n    if (!isStructField(idl)) {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idl),\n        });\n    }\n\n    return structFieldTypeNode({\n        docs: idl.docs ?? [],\n        name: idl.name,\n        type: typeNodeFromAnchorV01(idl.type, generics),\n    });\n}\n\nfunction isStructField(field: IdlV01Field | IdlV01Type): field is IdlV01Field {\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumTupleVariantTypeNode, enumTupleVariantTypeNode, TupleTypeNode } from '@codama/nodes';\n\nimport type { IdlV01DefinedFieldsTuple, IdlV01EnumVariant } from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { tupleTypeNodeFromAnchorV01 } from './TupleTypeNode';\n\nexport function enumTupleVariantTypeNodeFromAnchorV01(\n    idl: IdlV01EnumVariant & { fields: IdlV01DefinedFieldsTuple },\n    generics: GenericsV01,\n): EnumTupleVariantTypeNode<TupleTypeNode> {\n    return enumTupleVariantTypeNode(idl.name ?? '', tupleTypeNodeFromAnchorV01(idl.fields, generics));\n}\n","import { TupleTypeNode, tupleTypeNode } from '@codama/nodes';\n\nimport type { IdlV01DefinedFieldsTuple } from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function tupleTypeNodeFromAnchorV01(idl: IdlV01DefinedFieldsTuple, generics: GenericsV01): TupleTypeNode {\n    return tupleTypeNode(idl.map(type => typeNodeFromAnchorV01(type, generics)));\n}\n","import { numberTypeNode, OptionTypeNode, optionTypeNode } from '@codama/nodes';\n\nimport type { IdlV01TypeCOption, IdlV01TypeOption } from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function optionTypeNodeFromAnchorV01(\n    idl: IdlV01TypeCOption | IdlV01TypeOption,\n    generics: GenericsV01,\n): OptionTypeNode {\n    const item = 'option' in idl ? idl.option : idl.coption;\n    const hasOptionField = 'option' in idl;\n\n    const prefix = numberTypeNode(hasOptionField ? 'u8' : 'u32');\n    const fixed = !hasOptionField;\n\n    return optionTypeNode(typeNodeFromAnchorV01(item, generics), {\n        fixed,\n        prefix,\n    });\n}\n","import { DefinedTypeNode, definedTypeNode } from '@codama/nodes';\n\nimport type { IdlV01TypeDef } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\nimport type { GenericsV01 } from './unwrapGenerics';\n\nexport function definedTypeNodeFromAnchorV01(idl: Partial<IdlV01TypeDef>, generics: GenericsV01): DefinedTypeNode {\n    const name = idl.name ?? '';\n    const idlType = idl.type ?? { fields: [], kind: 'struct' };\n    const type = typeNodeFromAnchorV01(idlType, generics);\n    return definedTypeNode({ docs: idl.docs, name, type });\n}\n","import { ErrorNode, errorNode } from '@codama/nodes';\n\nimport { IdlV01ErrorCode } from './idl';\n\nexport function errorNodeFromAnchorV01(idl: Partial<IdlV01ErrorCode>): ErrorNode {\n    const name = idl.name ?? '';\n    const msg = idl.msg ?? '';\n    return errorNode({\n        code: idl.code ?? -1,\n        docs: `${name}: ${msg}`,\n        message: msg,\n        name,\n    });\n}\n","import {\n    CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING,\n    CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING,\n    CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED,\n    CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED,\n    CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING,\n    CodamaError,\n} from '@codama/errors';\nimport {\n    AccountNode,\n    accountValueNode,\n    argumentValueNode,\n    camelCase,\n    constantPdaSeedNodeFromBytes,\n    InstructionAccountNode,\n    instructionAccountNode,\n    InstructionArgumentNode,\n    pdaNode,\n    PdaSeedNode,\n    PdaSeedValueNode,\n    pdaSeedValueNode,\n    PdaValueNode,\n    pdaValueNode,\n    publicKeyTypeNode,\n    PublicKeyValueNode,\n    publicKeyValueNode,\n    resolveNestedTypeNode,\n    variablePdaSeedNode,\n} from '@codama/nodes';\nimport { getBase58Codec } from '@solana/codecs';\n\nimport { hex } from '../utils';\nimport { IdlV01InstructionAccount, IdlV01InstructionAccountItem, IdlV01Seed } from './idl';\n\nexport function instructionAccountNodesFromAnchorV01(\n    allAccounts: AccountNode[],\n    instructionArguments: InstructionArgumentNode[],\n    idl: IdlV01InstructionAccountItem[],\n): InstructionAccountNode[] {\n    return idl.flatMap(account =>\n        'accounts' in account\n            ? instructionAccountNodesFromAnchorV01(allAccounts, instructionArguments, account.accounts)\n            : [instructionAccountNodeFromAnchorV01(allAccounts, instructionArguments, account, idl)],\n    );\n}\n\nexport function instructionAccountNodeFromAnchorV01(\n    allAccounts: AccountNode[],\n    instructionArguments: InstructionArgumentNode[],\n    idl: IdlV01InstructionAccount,\n    parentIdl: IdlV01InstructionAccountItem[],\n): InstructionAccountNode {\n    const isOptional = idl.optional ?? false;\n    const docs = idl.docs ?? [];\n    const isSigner = idl.signer ?? false;\n    const isWritable = idl.writable ?? false;\n    const name = idl.name ?? '';\n    let defaultValue: PdaValueNode | PublicKeyValueNode | undefined;\n\n    if (idl.address) {\n        defaultValue = publicKeyValueNode(idl.address, name);\n    } else if (idl.pda) {\n        // TODO: Handle seeds with nested paths.\n        // Currently, we gracefully ignore PDA default values if we encounter seeds with nested paths.\n        const seedsWithNestedPaths = idl.pda.seeds.some(seed => 'path' in seed && seed.path.includes('.'));\n        if (!seedsWithNestedPaths) {\n            const [seeds, lookups] = idl.pda.seeds.reduce(\n                ([seeds, lookups], seed: IdlV01Seed) => {\n                    const kind = seed.kind;\n\n                    switch (kind) {\n                        case 'const':\n                            return [[...seeds, constantPdaSeedNodeFromBytes('base16', hex(seed.value))], lookups];\n                        case 'account': {\n                            const path = seed.path.split('.');\n                            if (path.length === 1) {\n                                return [\n                                    [...seeds, variablePdaSeedNode(seed.path, publicKeyTypeNode())],\n                                    [...lookups, pdaSeedValueNode(seed.path, accountValueNode(seed.path))],\n                                ];\n                            } else if (path.length === 2) {\n                                // TODO: Handle nested account paths.\n                                // Currently, this scenario is never reached.\n\n                                const accountName = camelCase(seed.account ?? '');\n                                const accountNode = allAccounts.find(({ name }) => name === accountName);\n                                if (!accountNode) {\n                                    throw new CodamaError(CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { kind });\n                                }\n\n                                const fieldName = camelCase(path[1]);\n                                const accountFields = resolveNestedTypeNode(accountNode.data).fields;\n                                const fieldNode = accountFields.find(({ name }) => name === fieldName);\n                                if (!fieldNode) {\n                                    throw new CodamaError(CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING, {\n                                        idlType: seed.account,\n                                        path: seed.path,\n                                    });\n                                }\n\n                                const seedName = camelCase(seed.path);\n                                return [[...seeds, variablePdaSeedNode(seedName, fieldNode.type)], []];\n                            } else {\n                                throw new CodamaError(CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING, {\n                                    idlType: seed,\n                                    path: seed.path,\n                                });\n                            }\n                        }\n                        case 'arg': {\n                            const argumentName = camelCase(seed.path);\n                            const argumentNode = instructionArguments.find(({ name }) => name === argumentName);\n                            if (!argumentNode) {\n                                throw new CodamaError(CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING, { name: seed.path });\n                            }\n\n                            return [\n                                [...seeds, variablePdaSeedNode(seed.path, argumentNode.type)],\n                                [...lookups, pdaSeedValueNode(seed.path, argumentValueNode(seed.path))],\n                            ];\n                        }\n                        default:\n                            throw new CodamaError(CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED, { kind });\n                    }\n                },\n                <[PdaSeedNode[], PdaSeedValueNode[]]>[[], []],\n            );\n\n            let programId: string | undefined;\n            if (idl.pda.program !== undefined) {\n                const kind = idl.pda.program.kind;\n                switch (kind) {\n                    case 'const': {\n                        programId = getBase58Codec().decode(new Uint8Array(idl.pda.program.value));\n                        break;\n                    }\n                    case 'account': {\n                        const programPath = idl.pda.program.path;\n                        const programNode = parentIdl.find(acc => acc.name == programPath);\n                        if (!(programNode && 'address' in programNode)) {\n                            throw new CodamaError(CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED, { kind });\n                        }\n                        programId = programNode.address;\n                        break;\n                    }\n                    default: {\n                        throw new CodamaError(CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED, { kind });\n                    }\n                }\n            }\n\n            defaultValue = pdaValueNode(\n                pdaNode({ name, seeds, ...(programId !== undefined ? { programId } : {}) }),\n                lookups,\n            );\n        }\n    }\n\n    return instructionAccountNode({\n        defaultValue,\n        docs,\n        isOptional,\n        isSigner,\n        isWritable,\n        name,\n    });\n}\n","import { InstructionArgumentNode, instructionArgumentNode } from '@codama/nodes';\n\nimport type { IdlV01Field } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\nimport type { GenericsV01 } from './unwrapGenerics';\n\nexport function instructionArgumentNodeFromAnchorV01(idl: IdlV01Field, generics: GenericsV01): InstructionArgumentNode {\n    return instructionArgumentNode({\n        docs: idl.docs ?? [],\n        name: idl.name,\n        type: typeNodeFromAnchorV01(idl.type, generics),\n    });\n}\n","import {\n    AccountNode,\n    bytesTypeNode,\n    camelCase,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    instructionArgumentNode,\n    InstructionNode,\n    instructionNode,\n} from '@codama/nodes';\n\nimport { getAnchorDiscriminatorV01 } from '../discriminators';\nimport type { IdlV01Instruction } from './idl';\nimport { instructionAccountNodesFromAnchorV01 } from './InstructionAccountNode';\nimport { instructionArgumentNodeFromAnchorV01 } from './InstructionArgumentNode';\nimport type { GenericsV01 } from './unwrapGenerics';\n\nexport function instructionNodeFromAnchorV01(\n    allAccounts: AccountNode[],\n    idl: IdlV01Instruction,\n    generics: GenericsV01,\n): InstructionNode {\n    const name = idl.name;\n    let dataArguments = idl.args.map(arg => instructionArgumentNodeFromAnchorV01(arg, generics));\n\n    const discriminatorField = instructionArgumentNode({\n        defaultValue: getAnchorDiscriminatorV01(idl.discriminator),\n        defaultValueStrategy: 'omitted',\n        name: 'discriminator',\n        type: fixedSizeTypeNode(bytesTypeNode(), idl.discriminator.length),\n    });\n    dataArguments = [discriminatorField, ...dataArguments];\n    const discriminators = [fieldDiscriminatorNode('discriminator')];\n\n    return instructionNode({\n        accounts: instructionAccountNodesFromAnchorV01(allAccounts, dataArguments, idl.accounts ?? []),\n        arguments: dataArguments,\n        discriminators,\n        docs: idl.docs ?? [],\n        name: camelCase(name),\n        optionalAccountStrategy: 'programId',\n    });\n}\n","import { ProgramNode, programNode, ProgramVersion } from '@codama/nodes';\n\nimport { accountNodeFromAnchorV01 } from './AccountNode';\nimport { definedTypeNodeFromAnchorV01 } from './DefinedTypeNode';\nimport { errorNodeFromAnchorV01 } from './ErrorNode';\nimport { IdlV01 } from './idl';\nimport { instructionNodeFromAnchorV01 } from './InstructionNode';\nimport { extractGenerics } from './unwrapGenerics';\n\nexport function programNodeFromAnchorV01(idl: IdlV01): ProgramNode {\n    const [types, generics] = extractGenerics(idl.types ?? []);\n    const accounts = idl.accounts ?? [];\n    const instructions = idl.instructions ?? [];\n    const errors = idl.errors ?? [];\n\n    const filteredTypes = types.filter(type => !accounts.some(account => account.name === type.name));\n    const definedTypes = filteredTypes.map(type => definedTypeNodeFromAnchorV01(type, generics));\n    const accountNodes = accounts.map(account => accountNodeFromAnchorV01(account, types, generics));\n\n    return programNode({\n        accounts: accountNodes,\n        definedTypes,\n        errors: errors.map(errorNodeFromAnchorV01),\n        instructions: instructions.map(instruction =>\n            instructionNodeFromAnchorV01(accountNodes, instruction, generics),\n        ),\n        name: idl.metadata.name,\n        origin: 'anchor',\n        publicKey: idl.address,\n        version: idl.metadata.version as ProgramVersion,\n    });\n}\n","import { RootNode, rootNode } from '@codama/nodes';\n\nimport { IdlV01 } from './idl';\nimport { programNodeFromAnchorV01 } from './ProgramNode';\n\nexport function rootNodeFromAnchorV01(program: IdlV01, additionalPrograms: IdlV01[] = []): RootNode {\n    const programNode = programNodeFromAnchorV01(program);\n    const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV01);\n    return rootNode(programNode, additionalProgramNodes);\n}\n"],"mappings":"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","names":["import_visitors","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","item","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","programNode","import_errors","import_nodes","import_nodes","import_errors","import_nodes","import_errors","import_nodes","import_nodes","import_nodes","import_nodes","import_errors","import_nodes","import_nodes","import_nodes","isStructVariant","import_nodes","isArrayOfSize","isStructField","item","name","import_nodes","import_nodes","import_errors","import_nodes","seeds","lookups","accountNode","name","programNode","import_nodes","import_nodes","import_nodes","import_nodes","programNode"]}