"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  accountNodeFromAnchorV00: () => accountNodeFromAnchorV00,
  accountNodeFromAnchorV01: () => accountNodeFromAnchorV01,
  arrayTypeNodeFromAnchorV00: () => arrayTypeNodeFromAnchorV00,
  arrayTypeNodeFromAnchorV01: () => arrayTypeNodeFromAnchorV01,
  defaultVisitor: () => defaultVisitor,
  definedTypeNodeFromAnchorV00: () => definedTypeNodeFromAnchorV00,
  definedTypeNodeFromAnchorV01: () => definedTypeNodeFromAnchorV01,
  enumEmptyVariantTypeNodeFromAnchorV00: () => enumEmptyVariantTypeNodeFromAnchorV00,
  enumEmptyVariantTypeNodeFromAnchorV01: () => enumEmptyVariantTypeNodeFromAnchorV01,
  enumStructVariantTypeNodeFromAnchorV00: () => enumStructVariantTypeNodeFromAnchorV00,
  enumStructVariantTypeNodeFromAnchorV01: () => enumStructVariantTypeNodeFromAnchorV01,
  enumTupleVariantTypeNodeFromAnchorV00: () => enumTupleVariantTypeNodeFromAnchorV00,
  enumTupleVariantTypeNodeFromAnchorV01: () => enumTupleVariantTypeNodeFromAnchorV01,
  enumTypeNodeFromAnchorV00: () => enumTypeNodeFromAnchorV00,
  enumTypeNodeFromAnchorV01: () => enumTypeNodeFromAnchorV01,
  errorNodeFromAnchorV00: () => errorNodeFromAnchorV00,
  errorNodeFromAnchorV01: () => errorNodeFromAnchorV01,
  extractGenerics: () => extractGenerics,
  getAnchorAccountDiscriminatorV00: () => getAnchorAccountDiscriminatorV00,
  getAnchorDiscriminatorV01: () => getAnchorDiscriminatorV01,
  getAnchorInstructionDiscriminatorV00: () => getAnchorInstructionDiscriminatorV00,
  instructionAccountNodeFromAnchorV00: () => instructionAccountNodeFromAnchorV00,
  instructionAccountNodeFromAnchorV01: () => instructionAccountNodeFromAnchorV01,
  instructionAccountNodesFromAnchorV00: () => instructionAccountNodesFromAnchorV00,
  instructionAccountNodesFromAnchorV01: () => instructionAccountNodesFromAnchorV01,
  instructionArgumentNodeFromAnchorV00: () => instructionArgumentNodeFromAnchorV00,
  instructionArgumentNodeFromAnchorV01: () => instructionArgumentNodeFromAnchorV01,
  instructionNodeFromAnchorV00: () => instructionNodeFromAnchorV00,
  instructionNodeFromAnchorV01: () => instructionNodeFromAnchorV01,
  mapTypeNodeFromAnchorV00: () => mapTypeNodeFromAnchorV00,
  optionTypeNodeFromAnchorV00: () => optionTypeNodeFromAnchorV00,
  optionTypeNodeFromAnchorV01: () => optionTypeNodeFromAnchorV01,
  pdaNodeFromAnchorV00: () => pdaNodeFromAnchorV00,
  programNodeFromAnchorV00: () => programNodeFromAnchorV00,
  programNodeFromAnchorV01: () => programNodeFromAnchorV01,
  rootNodeFromAnchor: () => rootNodeFromAnchor,
  rootNodeFromAnchorV00: () => rootNodeFromAnchorV00,
  rootNodeFromAnchorV01: () => rootNodeFromAnchorV01,
  rootNodeFromAnchorWithoutDefaultVisitor: () => rootNodeFromAnchorWithoutDefaultVisitor,
  setTypeNodeFromAnchorV00: () => setTypeNodeFromAnchorV00,
  structFieldTypeNodeFromAnchorV00: () => structFieldTypeNodeFromAnchorV00,
  structFieldTypeNodeFromAnchorV01: () => structFieldTypeNodeFromAnchorV01,
  structTypeNodeFromAnchorV00: () => structTypeNodeFromAnchorV00,
  structTypeNodeFromAnchorV01: () => structTypeNodeFromAnchorV01,
  tupleTypeNodeFromAnchorV00: () => tupleTypeNodeFromAnchorV00,
  tupleTypeNodeFromAnchorV01: () => tupleTypeNodeFromAnchorV01,
  typeNodeFromAnchorV00: () => typeNodeFromAnchorV00,
  typeNodeFromAnchorV01: () => typeNodeFromAnchorV01,
  unwrapGenericTypeFromAnchorV01: () => unwrapGenericTypeFromAnchorV01
});
module.exports = __toCommonJS(index_exports);
var import_visitors2 = require("@codama/visitors");

// src/defaultVisitor.ts
var import_nodes = require("@codama/nodes");
var import_visitors = require("@codama/visitors");
function defaultVisitor() {
  return (0, import_visitors.rootNodeVisitor)((currentRoot) => {
    let root = currentRoot;
    const updateRoot = (visitor) => {
      const newRoot = (0, import_visitors.visit)(root, visitor);
      (0, import_nodes.assertIsNode)(newRoot, "rootNode");
      root = newRoot;
    };
    updateRoot((0, import_visitors.deduplicateIdenticalDefinedTypesVisitor)());
    updateRoot((0, import_visitors.setFixedAccountSizesVisitor)());
    updateRoot((0, import_visitors.setInstructionAccountDefaultValuesVisitor)((0, import_visitors.getCommonInstructionAccountDefaultRules)()));
    updateRoot((0, import_visitors.unwrapInstructionArgsDefinedTypesVisitor)());
    updateRoot((0, import_visitors.flattenInstructionDataArgumentsVisitor)());
    updateRoot((0, import_visitors.transformU8ArraysToBytesVisitor)());
    return root;
  });
}

// src/v00/AccountNode.ts
var import_nodes15 = require("@codama/nodes");

// src/discriminators.ts
var import_nodes2 = require("@codama/nodes");
var import_sha2 = require("@noble/hashes/sha2");

// src/utils.ts
function hex(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// src/discriminators.ts
var getAnchorDiscriminatorV01 = (discriminator) => {
  return (0, import_nodes2.bytesValueNode)("base16", hex(new Uint8Array(discriminator)));
};
var getAnchorInstructionDiscriminatorV00 = (idlName) => {
  const hash = (0, import_sha2.sha256)(`global:${(0, import_nodes2.snakeCase)(idlName)}`).slice(0, 8);
  return (0, import_nodes2.bytesValueNode)("base16", hex(hash));
};
var getAnchorAccountDiscriminatorV00 = (idlName) => {
  const hash = (0, import_sha2.sha256)(`account:${(0, import_nodes2.pascalCase)(idlName)}`).slice(0, 8);
  return (0, import_nodes2.bytesValueNode)("base16", hex(hash));
};

// src/v00/typeNodes/ArrayTypeNode.ts
var import_nodes14 = require("@codama/nodes");

// src/v00/typeNodes/TypeNode.ts
var import_errors = require("@codama/errors");
var import_nodes13 = require("@codama/nodes");

// src/v00/typeNodes/EnumTypeNode.ts
var import_nodes9 = require("@codama/nodes");

// src/v00/typeNodes/EnumEmptyVariantTypeNode.ts
var import_nodes3 = require("@codama/nodes");
function enumEmptyVariantTypeNodeFromAnchorV00(idl) {
  return (0, import_nodes3.enumEmptyVariantTypeNode)(idl.name ?? "");
}

// src/v00/typeNodes/EnumStructVariantTypeNode.ts
var import_nodes6 = require("@codama/nodes");

// src/v00/typeNodes/StructTypeNode.ts
var import_nodes5 = require("@codama/nodes");

// src/v00/typeNodes/StructFieldTypeNode.ts
var import_nodes4 = require("@codama/nodes");
function structFieldTypeNodeFromAnchorV00(idl) {
  return (0, import_nodes4.structFieldTypeNode)({
    docs: idl.docs ?? [],
    name: idl.name ?? "",
    type: typeNodeFromAnchorV00(idl.type)
  });
}

// src/v00/typeNodes/StructTypeNode.ts
function structTypeNodeFromAnchorV00(idl) {
  return (0, import_nodes5.structTypeNode)((idl.fields ?? []).map(structFieldTypeNodeFromAnchorV00));
}

// src/v00/typeNodes/EnumStructVariantTypeNode.ts
function enumStructVariantTypeNodeFromAnchorV00(idl) {
  return (0, import_nodes6.enumStructVariantTypeNode)(
    idl.name ?? "",
    structTypeNodeFromAnchorV00({ fields: idl.fields, kind: "struct" })
  );
}

// src/v00/typeNodes/EnumTupleVariantTypeNode.ts
var import_nodes8 = require("@codama/nodes");

// src/v00/typeNodes/TupleTypeNode.ts
var import_nodes7 = require("@codama/nodes");
function tupleTypeNodeFromAnchorV00(idl) {
  return (0, import_nodes7.tupleTypeNode)(idl.tuple.map(typeNodeFromAnchorV00));
}

// src/v00/typeNodes/EnumTupleVariantTypeNode.ts
function enumTupleVariantTypeNodeFromAnchorV00(idl) {
  return (0, import_nodes8.enumTupleVariantTypeNode)(idl.name ?? "", tupleTypeNodeFromAnchorV00({ tuple: idl.fields }));
}

// src/v00/typeNodes/EnumTypeNode.ts
function enumTypeNodeFromAnchorV00(idl) {
  const variants = idl.variants.map((variant) => {
    if (!variant.fields || variant.fields.length <= 0) {
      return enumEmptyVariantTypeNodeFromAnchorV00(variant);
    }
    if (isStructVariant(variant)) {
      return enumStructVariantTypeNodeFromAnchorV00(variant);
    }
    return enumTupleVariantTypeNodeFromAnchorV00(variant);
  });
  return (0, import_nodes9.enumTypeNode)(variants, {
    size: idl.size ? (0, import_nodes9.numberTypeNode)(idl.size) : void 0
  });
}
function isStructVariant(variant) {
  const field = variant.fields[0];
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v00/typeNodes/MapTypeNode.ts
var import_nodes10 = require("@codama/nodes");
function mapTypeNodeFromAnchorV00(idl) {
  const [key, value] = "hashMap" in idl ? idl.hashMap : idl.bTreeMap;
  let size;
  if (idl.size === "remainder") {
    size = (0, import_nodes10.remainderCountNode)();
  } else if (typeof idl.size === "number") {
    size = (0, import_nodes10.fixedCountNode)(idl.size);
  } else {
    size = (0, import_nodes10.prefixedCountNode)((0, import_nodes10.numberTypeNode)(idl.size ?? "u32"));
  }
  return (0, import_nodes10.mapTypeNode)(typeNodeFromAnchorV00(key), typeNodeFromAnchorV00(value), size);
}

// src/v00/typeNodes/OptionTypeNode.ts
var import_nodes11 = require("@codama/nodes");
function optionTypeNodeFromAnchorV00(idl) {
  const item = "option" in idl ? idl.option : idl.coption;
  const defaultPrefix = (0, import_nodes11.numberTypeNode)("option" in idl ? "u8" : "u32");
  const defaultFixed = !("option" in idl);
  return (0, import_nodes11.optionTypeNode)(typeNodeFromAnchorV00(item), {
    fixed: idl.fixed !== void 0 ? idl.fixed : defaultFixed,
    prefix: idl.prefix ? (0, import_nodes11.numberTypeNode)(idl.prefix) : defaultPrefix
  });
}

// src/v00/typeNodes/SetTypeNode.ts
var import_nodes12 = require("@codama/nodes");
function setTypeNodeFromAnchorV00(idl) {
  const child = "hashSet" in idl ? idl.hashSet : idl.bTreeSet;
  let size;
  if (idl.size === "remainder") {
    size = (0, import_nodes12.remainderCountNode)();
  } else if (typeof idl.size === "number") {
    size = (0, import_nodes12.fixedCountNode)(idl.size);
  } else {
    size = (0, import_nodes12.prefixedCountNode)((0, import_nodes12.numberTypeNode)(idl.size ?? "u32"));
  }
  return (0, import_nodes12.setTypeNode)(typeNodeFromAnchorV00(child), size);
}

// src/v00/typeNodes/TypeNode.ts
var IDL_V00_TYPE_LEAVES = [
  "string",
  "publicKey",
  "bytes",
  "bool",
  "u8",
  "u16",
  "u32",
  "u64",
  "u128",
  "i8",
  "i16",
  "i32",
  "i64",
  "i128",
  "f32",
  "f64",
  "shortU16"
];
var typeNodeFromAnchorV00 = (idlType) => {
  if (typeof idlType === "string" && IDL_V00_TYPE_LEAVES.includes(idlType)) {
    if (idlType === "bool") return (0, import_nodes13.booleanTypeNode)();
    if (idlType === "publicKey") return (0, import_nodes13.publicKeyTypeNode)();
    if (idlType === "string") return (0, import_nodes13.sizePrefixTypeNode)((0, import_nodes13.stringTypeNode)("utf8"), (0, import_nodes13.numberTypeNode)("u32"));
    if (idlType === "bytes") return (0, import_nodes13.sizePrefixTypeNode)((0, import_nodes13.bytesTypeNode)(), (0, import_nodes13.numberTypeNode)("u32"));
    return (0, import_nodes13.numberTypeNode)(idlType);
  }
  if (typeof idlType !== "object") {
    throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
      idlType: JSON.stringify(idlType)
    });
  }
  if ("array" in idlType && isArrayOfSize(idlType.array, 2)) {
    return arrayTypeNodeFromAnchorV00(idlType);
  }
  if ("vec" in idlType) {
    return arrayTypeNodeFromAnchorV00(idlType);
  }
  if ("defined" in idlType && typeof idlType.defined === "string") {
    return (0, import_nodes13.definedTypeLinkNode)(idlType.defined);
  }
  if ("kind" in idlType && idlType.kind === "enum" && "variants" in idlType) {
    return enumTypeNodeFromAnchorV00(idlType);
  }
  if ("kind" in idlType && idlType.kind === "alias" && "value" in idlType) {
    return typeNodeFromAnchorV00(idlType.value);
  }
  if ("hashMap" in idlType && isArrayOfSize(idlType.hashMap, 2) || "bTreeMap" in idlType && isArrayOfSize(idlType.bTreeMap, 2)) {
    return mapTypeNodeFromAnchorV00(idlType);
  }
  if ("option" in idlType || "coption" in idlType) {
    return optionTypeNodeFromAnchorV00(idlType);
  }
  if ("hashSet" in idlType || "bTreeSet" in idlType) {
    return setTypeNodeFromAnchorV00(idlType);
  }
  if ("kind" in idlType && "fields" in idlType && idlType.kind === "struct") {
    return structTypeNodeFromAnchorV00(idlType);
  }
  if ("tuple" in idlType && Array.isArray(idlType.tuple)) {
    return tupleTypeNodeFromAnchorV00(idlType);
  }
  throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
    idlType: JSON.stringify(idlType)
  });
};
function isArrayOfSize(array, size) {
  return Array.isArray(array) && array.length === size;
}

// src/v00/typeNodes/ArrayTypeNode.ts
function arrayTypeNodeFromAnchorV00(idl) {
  if ("array" in idl) {
    const item2 = typeNodeFromAnchorV00(idl.array[0]);
    return (0, import_nodes14.arrayTypeNode)(item2, (0, import_nodes14.fixedCountNode)(idl.array[1]));
  }
  const item = typeNodeFromAnchorV00(idl.vec);
  if (idl.size === "remainder") return (0, import_nodes14.arrayTypeNode)(item, (0, import_nodes14.remainderCountNode)());
  return (0, import_nodes14.arrayTypeNode)(item, (0, import_nodes14.prefixedCountNode)((0, import_nodes14.numberTypeNode)(idl.size ?? "u32")));
}

// src/v00/AccountNode.ts
function accountNodeFromAnchorV00(idl, origin) {
  const idlName = idl.name ?? "";
  const name = (0, import_nodes15.camelCase)(idlName);
  const idlStruct = idl.type ?? { fields: [], kind: "struct" };
  let data = structTypeNodeFromAnchorV00(idlStruct);
  (0, import_nodes15.assertIsNode)(data, "structTypeNode");
  const hasSeeds = (idl.seeds ?? []).length > 0;
  let discriminators;
  if (origin === "anchor") {
    const discriminator = (0, import_nodes15.structFieldTypeNode)({
      defaultValue: getAnchorAccountDiscriminatorV00(idlName),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: (0, import_nodes15.fixedSizeTypeNode)((0, import_nodes15.bytesTypeNode)(), 8)
    });
    data = (0, import_nodes15.structTypeNode)([discriminator, ...data.fields]);
    discriminators = [(0, import_nodes15.fieldDiscriminatorNode)("discriminator")];
  }
  return (0, import_nodes15.accountNode)({
    data,
    discriminators,
    docs: idl.docs ?? [],
    name,
    pda: hasSeeds ? (0, import_nodes15.pdaLinkNode)(name) : void 0,
    size: idl.size
  });
}

// src/v00/DefinedTypeNode.ts
var import_nodes16 = require("@codama/nodes");
function definedTypeNodeFromAnchorV00(idl) {
  const name = idl.name ?? "";
  const idlType = idl.type ?? { fields: [], kind: "struct" };
  const type = typeNodeFromAnchorV00(idlType);
  return (0, import_nodes16.definedTypeNode)({ docs: idl.docs, name, type });
}

// src/v00/ErrorNode.ts
var import_nodes17 = require("@codama/nodes");
function errorNodeFromAnchorV00(idl) {
  const name = idl.name ?? "";
  const msg = idl.msg ?? "";
  return (0, import_nodes17.errorNode)({
    code: idl.code ?? -1,
    docs: idl.docs ?? [msg ? `${name}: ${msg}` : `${name}`],
    message: msg,
    name
  });
}

// src/v00/InstructionAccountNode.ts
var import_nodes18 = require("@codama/nodes");
function instructionAccountNodesFromAnchorV00(idl) {
  return idl.flatMap(
    (account) => "accounts" in account ? instructionAccountNodesFromAnchorV00(account.accounts) : [instructionAccountNodeFromAnchorV00(account)]
  );
}
function instructionAccountNodeFromAnchorV00(idl) {
  const isOptional = idl.optional ?? idl.isOptional ?? false;
  const desc = idl.desc ? [idl.desc] : void 0;
  return (0, import_nodes18.instructionAccountNode)({
    docs: idl.docs ?? desc ?? [],
    isOptional,
    isSigner: idl.isOptionalSigner ? "either" : idl.isSigner ?? false,
    isWritable: idl.isMut ?? false,
    name: idl.name ?? ""
  });
}

// src/v00/InstructionArgumentNode.ts
var import_nodes19 = require("@codama/nodes");
function instructionArgumentNodeFromAnchorV00(idl) {
  return (0, import_nodes19.instructionArgumentNode)({
    docs: idl.docs ?? [],
    name: idl.name ?? "",
    type: typeNodeFromAnchorV00(idl.type)
  });
}

// src/v00/InstructionNode.ts
var import_nodes20 = require("@codama/nodes");
function instructionNodeFromAnchorV00(idl, ixIndex, origin) {
  const idlName = idl.name ?? "";
  const name = (0, import_nodes20.camelCase)(idlName);
  let dataArguments = (idl.args ?? []).map(instructionArgumentNodeFromAnchorV00);
  let discriminators;
  if (idl.discriminant) {
    const discriminatorField = (0, import_nodes20.instructionArgumentNode)({
      defaultValue: (0, import_nodes20.numberValueNode)(idl.discriminant.value),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: typeNodeFromAnchorV00(idl.discriminant.type)
    });
    dataArguments = [discriminatorField, ...dataArguments];
    discriminators = [(0, import_nodes20.fieldDiscriminatorNode)("discriminator")];
  } else if (origin === "anchor") {
    const discriminatorField = (0, import_nodes20.instructionArgumentNode)({
      defaultValue: getAnchorInstructionDiscriminatorV00(idlName),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: (0, import_nodes20.fixedSizeTypeNode)((0, import_nodes20.bytesTypeNode)(), 8)
    });
    dataArguments = [discriminatorField, ...dataArguments];
    discriminators = [(0, import_nodes20.fieldDiscriminatorNode)("discriminator")];
  } else if (origin === "shank") {
    const discriminatorField = (0, import_nodes20.instructionArgumentNode)({
      defaultValue: (0, import_nodes20.bytesValueNode)("base16", ixIndex.toString(16)),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: (0, import_nodes20.fixedSizeTypeNode)((0, import_nodes20.bytesTypeNode)(), 1)
    });
    dataArguments = [discriminatorField, ...dataArguments];
    discriminators = [(0, import_nodes20.fieldDiscriminatorNode)("discriminator")];
  }
  return (0, import_nodes20.instructionNode)({
    accounts: instructionAccountNodesFromAnchorV00(idl.accounts ?? []),
    arguments: dataArguments,
    discriminators,
    docs: idl.docs ?? [],
    name,
    optionalAccountStrategy: idl.legacyOptionalAccountsStrategy ? "omitted" : "programId"
  });
}

// src/v00/PdaNode.ts
var import_nodes21 = require("@codama/nodes");
function pdaNodeFromAnchorV00(idl) {
  const name = (0, import_nodes21.camelCase)(idl.name ?? "");
  const seeds = (idl.seeds ?? []).map((seed) => {
    if (seed.kind === "constant") {
      const type = (() => {
        if (seed.type === "string") return (0, import_nodes21.stringTypeNode)("utf8");
        if (seed.type === "bytes") return (0, import_nodes21.bytesTypeNode)();
        return typeNodeFromAnchorV00(seed.type);
      })();
      const value = (() => {
        if (typeof seed.value === "string") return (0, import_nodes21.stringValueNode)(seed.value);
        if (typeof seed.value === "number") return (0, import_nodes21.numberValueNode)(seed.value);
        return (0, import_nodes21.booleanValueNode)(seed.value);
      })();
      return (0, import_nodes21.constantPdaSeedNode)(type, value);
    }
    if (seed.kind === "variable") {
      return (0, import_nodes21.variablePdaSeedNode)(
        seed.name,
        typeNodeFromAnchorV00(seed.type),
        seed.description ? [seed.description] : []
      );
    }
    return (0, import_nodes21.constantPdaSeedNodeFromProgramId)();
  });
  return (0, import_nodes21.pdaNode)({ name, seeds });
}

// src/v00/ProgramNode.ts
var import_nodes22 = require("@codama/nodes");
function programNodeFromAnchorV00(idl) {
  const origin = idl?.metadata?.origin ?? "anchor";
  const pdas = (idl.accounts ?? []).filter((account) => (account.seeds ?? []).length > 0).map(pdaNodeFromAnchorV00);
  const accounts = (idl.accounts ?? []).map((a) => accountNodeFromAnchorV00(a, origin));
  const instructions = (idl.instructions ?? []).map(
    (instruction, index) => instructionNodeFromAnchorV00(instruction, index, origin)
  );
  return (0, import_nodes22.programNode)({
    accounts,
    definedTypes: (idl?.types ?? []).map(definedTypeNodeFromAnchorV00),
    errors: (idl?.errors ?? []).map(errorNodeFromAnchorV00),
    instructions,
    name: idl?.name ?? "",
    origin,
    pdas,
    publicKey: idl?.metadata?.address ?? "",
    version: idl.version
  });
}

// src/v00/RootNode.ts
var import_nodes23 = require("@codama/nodes");
function rootNodeFromAnchorV00(program, additionalPrograms = []) {
  const programNode3 = programNodeFromAnchorV00(program);
  const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV00);
  return (0, import_nodes23.rootNode)(programNode3, additionalProgramNodes);
}

// src/v01/AccountNode.ts
var import_errors5 = require("@codama/errors");
var import_nodes34 = require("@codama/nodes");

// src/v01/typeNodes/ArrayTypeNode.ts
var import_nodes33 = require("@codama/nodes");

// src/v01/typeNodes/TypeNode.ts
var import_errors4 = require("@codama/errors");
var import_nodes32 = require("@codama/nodes");

// src/v01/unwrapGenerics.ts
var import_errors2 = require("@codama/errors");
function extractGenerics(types) {
  const [nonGenericTypes, genericTypes] = types.reduce(
    (acc, type) => {
      acc["generics" in type ? 1 : 0].push(type);
      return acc;
    },
    [[], []]
  );
  const generics = {
    constArgs: {},
    typeArgs: {},
    types: Object.fromEntries(genericTypes.map((type) => [type.name, type]))
  };
  return [nonGenericTypes, generics];
}
function unwrapGenericTypeFromAnchorV01(type, generics) {
  const genericType = generics.types[type.defined.name];
  if (!genericType) {
    throw new import_errors2.CodamaError(import_errors2.CODAMA_ERROR__ANCHOR__GENERIC_TYPE_MISSING, { name: type.defined.name });
  }
  const constArgs = {};
  const typeArgs = {};
  const genericDefinitions = genericType.generics ?? [];
  const genericArgs = type.defined.generics ?? [];
  genericDefinitions.forEach((genericDefinition, index) => {
    const genericArg = genericArgs[index];
    if (genericDefinition.kind === "const") {
      constArgs[genericDefinition.name] = genericArg;
    } else {
      typeArgs[genericDefinition.name] = genericArg;
    }
  });
  return typeNodeFromAnchorV01(genericType.type, {
    ...generics,
    constArgs: { ...generics.constArgs, ...constArgs },
    typeArgs: { ...generics.typeArgs, ...typeArgs }
  });
}

// src/v01/typeNodes/EnumTypeNode.ts
var import_nodes30 = require("@codama/nodes");

// src/v01/typeNodes/EnumEmptyVariantTypeNode.ts
var import_nodes24 = require("@codama/nodes");
function enumEmptyVariantTypeNodeFromAnchorV01(idl) {
  return (0, import_nodes24.enumEmptyVariantTypeNode)(idl.name ?? "");
}

// src/v01/typeNodes/EnumStructVariantTypeNode.ts
var import_nodes27 = require("@codama/nodes");

// src/v01/typeNodes/StructTypeNode.ts
var import_nodes26 = require("@codama/nodes");

// src/v01/typeNodes/StructFieldTypeNode.ts
var import_errors3 = require("@codama/errors");
var import_nodes25 = require("@codama/nodes");
function structFieldTypeNodeFromAnchorV01(idl, generics) {
  if (!isStructField(idl)) {
    throw new import_errors3.CodamaError(import_errors3.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
      idlType: JSON.stringify(idl)
    });
  }
  return (0, import_nodes25.structFieldTypeNode)({
    docs: idl.docs ?? [],
    name: idl.name,
    type: typeNodeFromAnchorV01(idl.type, generics)
  });
}
function isStructField(field) {
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v01/typeNodes/StructTypeNode.ts
function structTypeNodeFromAnchorV01(idl, generics) {
  const fields = idl.fields ?? [];
  return (0, import_nodes26.structTypeNode)(fields.map((field) => structFieldTypeNodeFromAnchorV01(field, generics)));
}

// src/v01/typeNodes/EnumStructVariantTypeNode.ts
function enumStructVariantTypeNodeFromAnchorV01(idl, generics) {
  return (0, import_nodes27.enumStructVariantTypeNode)(
    idl.name ?? "",
    structTypeNodeFromAnchorV01({ fields: idl.fields, kind: "struct" }, generics)
  );
}

// src/v01/typeNodes/EnumTupleVariantTypeNode.ts
var import_nodes29 = require("@codama/nodes");

// src/v01/typeNodes/TupleTypeNode.ts
var import_nodes28 = require("@codama/nodes");
function tupleTypeNodeFromAnchorV01(idl, generics) {
  return (0, import_nodes28.tupleTypeNode)(idl.map((type) => typeNodeFromAnchorV01(type, generics)));
}

// src/v01/typeNodes/EnumTupleVariantTypeNode.ts
function enumTupleVariantTypeNodeFromAnchorV01(idl, generics) {
  return (0, import_nodes29.enumTupleVariantTypeNode)(idl.name ?? "", tupleTypeNodeFromAnchorV01(idl.fields, generics));
}

// src/v01/typeNodes/EnumTypeNode.ts
function enumTypeNodeFromAnchorV01(idl, generics) {
  const variants = idl.variants.map((variant) => {
    if (!variant.fields || variant.fields.length <= 0) {
      return enumEmptyVariantTypeNodeFromAnchorV01(variant);
    }
    if (isStructVariant2(variant)) {
      return enumStructVariantTypeNodeFromAnchorV01(variant, generics);
    }
    return enumTupleVariantTypeNodeFromAnchorV01(
      variant,
      generics
    );
  });
  return (0, import_nodes30.enumTypeNode)(variants);
}
function isStructVariant2(variant) {
  const field = variant.fields[0];
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v01/typeNodes/OptionTypeNode.ts
var import_nodes31 = require("@codama/nodes");
function optionTypeNodeFromAnchorV01(idl, generics) {
  const item = "option" in idl ? idl.option : idl.coption;
  const hasOptionField = "option" in idl;
  const prefix = (0, import_nodes31.numberTypeNode)(hasOptionField ? "u8" : "u32");
  const fixed = !hasOptionField;
  return (0, import_nodes31.optionTypeNode)(typeNodeFromAnchorV01(item, generics), {
    fixed,
    prefix
  });
}

// src/v01/typeNodes/TypeNode.ts
var IDL_V01_TYPE_LEAVES = [
  "string",
  "pubkey",
  "bytes",
  "bool",
  "u8",
  "u16",
  "u32",
  "u64",
  "u128",
  "i8",
  "i16",
  "i32",
  "i64",
  "i128",
  "f32",
  "f64",
  "shortU16"
];
var typeNodeFromAnchorV01 = (idlType, generics) => {
  if (typeof idlType === "string" && IDL_V01_TYPE_LEAVES.includes(idlType)) {
    if (idlType === "bool") return (0, import_nodes32.booleanTypeNode)();
    if (idlType === "pubkey") return (0, import_nodes32.publicKeyTypeNode)();
    if (idlType === "string") return (0, import_nodes32.sizePrefixTypeNode)((0, import_nodes32.stringTypeNode)("utf8"), (0, import_nodes32.numberTypeNode)("u32"));
    if (idlType === "bytes") return (0, import_nodes32.sizePrefixTypeNode)((0, import_nodes32.bytesTypeNode)(), (0, import_nodes32.numberTypeNode)("u32"));
    return (0, import_nodes32.numberTypeNode)(idlType);
  }
  if (typeof idlType !== "object") {
    throw new import_errors4.CodamaError(import_errors4.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
      idlType: JSON.stringify(idlType)
    });
  }
  if ("array" in idlType && isArrayOfSize2(idlType.array, 2)) {
    return arrayTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("vec" in idlType) {
    return arrayTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("defined" in idlType && typeof idlType.defined === "object") {
    return "generics" in idlType.defined ? unwrapGenericTypeFromAnchorV01(idlType, generics) : (0, import_nodes32.definedTypeLinkNode)(idlType.defined.name);
  }
  if ("generic" in idlType) {
    return typeNodeFromAnchorV01(generics.typeArgs[idlType.generic].type, generics);
  }
  if ("kind" in idlType && idlType.kind === "enum" && "variants" in idlType) {
    return enumTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("kind" in idlType && idlType.kind === "alias" && "value" in idlType) {
    return typeNodeFromAnchorV01(idlType.value, generics);
  }
  if ("option" in idlType) {
    return optionTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("coption" in idlType) {
    return optionTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("kind" in idlType && idlType.kind === "struct") {
    const fields = idlType.fields ?? [];
    if (isStructFieldArray(fields)) {
      return structTypeNodeFromAnchorV01(idlType, generics);
    }
    if (isTupleFieldArray(fields)) {
      return tupleTypeNodeFromAnchorV01(fields, generics);
    }
  }
  throw new import_errors4.CodamaError(import_errors4.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
    idlType: JSON.stringify(idlType)
  });
};
function isArrayOfSize2(array, size) {
  return Array.isArray(array) && array.length === size;
}
function isStructFieldArray(field) {
  return field.every(isStructField2);
}
function isTupleFieldArray(field) {
  return field.every((f) => !isStructField2(f));
}
function isStructField2(field) {
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v01/typeNodes/ArrayTypeNode.ts
function arrayTypeNodeFromAnchorV01(idl, generics) {
  if ("array" in idl) {
    const item2 = typeNodeFromAnchorV01(idl.array[0], generics);
    const size = typeof idl.array[1] === "number" ? idl.array[1] : parseInt(generics.constArgs[idl.array[1].generic].value);
    return (0, import_nodes33.arrayTypeNode)(item2, (0, import_nodes33.fixedCountNode)(size));
  }
  const item = typeNodeFromAnchorV01(idl.vec, generics);
  return (0, import_nodes33.arrayTypeNode)(item, (0, import_nodes33.prefixedCountNode)((0, import_nodes33.numberTypeNode)("u32")));
}

// src/v01/AccountNode.ts
function accountNodeFromAnchorV01(idl, types, generics) {
  const name = (0, import_nodes34.camelCase)(idl.name);
  const type = types.find(({ name: name2 }) => name2 === idl.name);
  if (!type) {
    throw new import_errors5.CodamaError(import_errors5.CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { name: idl.name });
  }
  const data = typeNodeFromAnchorV01(type.type, generics);
  (0, import_nodes34.assertIsNode)(data, "structTypeNode");
  const discriminator = (0, import_nodes34.structFieldTypeNode)({
    defaultValue: getAnchorDiscriminatorV01(idl.discriminator),
    defaultValueStrategy: "omitted",
    name: "discriminator",
    type: (0, import_nodes34.fixedSizeTypeNode)((0, import_nodes34.bytesTypeNode)(), idl.discriminator.length)
  });
  return (0, import_nodes34.accountNode)({
    data: (0, import_nodes34.structTypeNode)([discriminator, ...data.fields]),
    discriminators: [(0, import_nodes34.fieldDiscriminatorNode)("discriminator")],
    name
  });
}

// src/v01/DefinedTypeNode.ts
var import_nodes35 = require("@codama/nodes");
function definedTypeNodeFromAnchorV01(idl, generics) {
  const name = idl.name ?? "";
  const idlType = idl.type ?? { fields: [], kind: "struct" };
  const type = typeNodeFromAnchorV01(idlType, generics);
  return (0, import_nodes35.definedTypeNode)({ docs: idl.docs, name, type });
}

// src/v01/ErrorNode.ts
var import_nodes36 = require("@codama/nodes");
function errorNodeFromAnchorV01(idl) {
  const name = idl.name ?? "";
  const msg = idl.msg ?? "";
  return (0, import_nodes36.errorNode)({
    code: idl.code ?? -1,
    docs: `${name}: ${msg}`,
    message: msg,
    name
  });
}

// src/v01/InstructionAccountNode.ts
var import_errors6 = require("@codama/errors");
var import_nodes37 = require("@codama/nodes");
var import_codecs = require("@solana/codecs");
function instructionAccountNodesFromAnchorV01(allAccounts, instructionArguments, idl) {
  return idl.flatMap(
    (account) => "accounts" in account ? instructionAccountNodesFromAnchorV01(allAccounts, instructionArguments, account.accounts) : [instructionAccountNodeFromAnchorV01(allAccounts, instructionArguments, account, idl)]
  );
}
function instructionAccountNodeFromAnchorV01(allAccounts, instructionArguments, idl, parentIdl) {
  const isOptional = idl.optional ?? false;
  const docs = idl.docs ?? [];
  const isSigner = idl.signer ?? false;
  const isWritable = idl.writable ?? false;
  const name = idl.name ?? "";
  let defaultValue;
  if (idl.address) {
    defaultValue = (0, import_nodes37.publicKeyValueNode)(idl.address, name);
  } else if (idl.pda) {
    const seedsWithNestedPaths = idl.pda.seeds.some((seed) => "path" in seed && seed.path.includes("."));
    if (!seedsWithNestedPaths) {
      const [seeds, lookups] = idl.pda.seeds.reduce(
        ([seeds2, lookups2], seed) => {
          const kind = seed.kind;
          switch (kind) {
            case "const":
              return [[...seeds2, (0, import_nodes37.constantPdaSeedNodeFromBytes)("base16", hex(seed.value))], lookups2];
            case "account": {
              const path = seed.path.split(".");
              if (path.length === 1) {
                return [
                  [...seeds2, (0, import_nodes37.variablePdaSeedNode)(seed.path, (0, import_nodes37.publicKeyTypeNode)())],
                  [...lookups2, (0, import_nodes37.pdaSeedValueNode)(seed.path, (0, import_nodes37.accountValueNode)(seed.path))]
                ];
              } else if (path.length === 2) {
                const accountName = (0, import_nodes37.camelCase)(seed.account ?? "");
                const accountNode3 = allAccounts.find(({ name: name2 }) => name2 === accountName);
                if (!accountNode3) {
                  throw new import_errors6.CodamaError(import_errors6.CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { kind });
                }
                const fieldName = (0, import_nodes37.camelCase)(path[1]);
                const accountFields = (0, import_nodes37.resolveNestedTypeNode)(accountNode3.data).fields;
                const fieldNode = accountFields.find(({ name: name2 }) => name2 === fieldName);
                if (!fieldNode) {
                  throw new import_errors6.CodamaError(import_errors6.CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING, {
                    idlType: seed.account,
                    path: seed.path
                  });
                }
                const seedName = (0, import_nodes37.camelCase)(seed.path);
                return [[...seeds2, (0, import_nodes37.variablePdaSeedNode)(seedName, fieldNode.type)], []];
              } else {
                throw new import_errors6.CodamaError(import_errors6.CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING, {
                  idlType: seed,
                  path: seed.path
                });
              }
            }
            case "arg": {
              const argumentName = (0, import_nodes37.camelCase)(seed.path);
              const argumentNode = instructionArguments.find(({ name: name2 }) => name2 === argumentName);
              if (!argumentNode) {
                throw new import_errors6.CodamaError(import_errors6.CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING, { name: seed.path });
              }
              return [
                [...seeds2, (0, import_nodes37.variablePdaSeedNode)(seed.path, argumentNode.type)],
                [...lookups2, (0, import_nodes37.pdaSeedValueNode)(seed.path, (0, import_nodes37.argumentValueNode)(seed.path))]
              ];
            }
            default:
              throw new import_errors6.CodamaError(import_errors6.CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED, { kind });
          }
        },
        [[], []]
      );
      let programId;
      if (idl.pda.program !== void 0) {
        const kind = idl.pda.program.kind;
        switch (kind) {
          case "const": {
            programId = (0, import_codecs.getBase58Codec)().decode(new Uint8Array(idl.pda.program.value));
            break;
          }
          case "account": {
            const programPath = idl.pda.program.path;
            const programNode3 = parentIdl.find((acc) => acc.name == programPath);
            if (!(programNode3 && "address" in programNode3)) {
              throw new import_errors6.CodamaError(import_errors6.CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED, { kind });
            }
            programId = programNode3.address;
            break;
          }
          default: {
            throw new import_errors6.CodamaError(import_errors6.CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED, { kind });
          }
        }
      }
      defaultValue = (0, import_nodes37.pdaValueNode)(
        (0, import_nodes37.pdaNode)({ name, seeds, ...programId !== void 0 ? { programId } : {} }),
        lookups
      );
    }
  }
  return (0, import_nodes37.instructionAccountNode)({
    defaultValue,
    docs,
    isOptional,
    isSigner,
    isWritable,
    name
  });
}

// src/v01/InstructionArgumentNode.ts
var import_nodes38 = require("@codama/nodes");
function instructionArgumentNodeFromAnchorV01(idl, generics) {
  return (0, import_nodes38.instructionArgumentNode)({
    docs: idl.docs ?? [],
    name: idl.name,
    type: typeNodeFromAnchorV01(idl.type, generics)
  });
}

// src/v01/InstructionNode.ts
var import_nodes39 = require("@codama/nodes");
function instructionNodeFromAnchorV01(allAccounts, idl, generics) {
  const name = idl.name;
  let dataArguments = idl.args.map((arg) => instructionArgumentNodeFromAnchorV01(arg, generics));
  const discriminatorField = (0, import_nodes39.instructionArgumentNode)({
    defaultValue: getAnchorDiscriminatorV01(idl.discriminator),
    defaultValueStrategy: "omitted",
    name: "discriminator",
    type: (0, import_nodes39.fixedSizeTypeNode)((0, import_nodes39.bytesTypeNode)(), idl.discriminator.length)
  });
  dataArguments = [discriminatorField, ...dataArguments];
  const discriminators = [(0, import_nodes39.fieldDiscriminatorNode)("discriminator")];
  return (0, import_nodes39.instructionNode)({
    accounts: instructionAccountNodesFromAnchorV01(allAccounts, dataArguments, idl.accounts ?? []),
    arguments: dataArguments,
    discriminators,
    docs: idl.docs ?? [],
    name: (0, import_nodes39.camelCase)(name),
    optionalAccountStrategy: "programId"
  });
}

// src/v01/ProgramNode.ts
var import_nodes40 = require("@codama/nodes");
function programNodeFromAnchorV01(idl) {
  const [types, generics] = extractGenerics(idl.types ?? []);
  const accounts = idl.accounts ?? [];
  const instructions = idl.instructions ?? [];
  const errors = idl.errors ?? [];
  const filteredTypes = types.filter((type) => !accounts.some((account) => account.name === type.name));
  const definedTypes = filteredTypes.map((type) => definedTypeNodeFromAnchorV01(type, generics));
  const accountNodes = accounts.map((account) => accountNodeFromAnchorV01(account, types, generics));
  return (0, import_nodes40.programNode)({
    accounts: accountNodes,
    definedTypes,
    errors: errors.map(errorNodeFromAnchorV01),
    instructions: instructions.map(
      (instruction) => instructionNodeFromAnchorV01(accountNodes, instruction, generics)
    ),
    name: idl.metadata.name,
    origin: "anchor",
    publicKey: idl.address,
    version: idl.metadata.version
  });
}

// src/v01/RootNode.ts
var import_nodes41 = require("@codama/nodes");
function rootNodeFromAnchorV01(program, additionalPrograms = []) {
  const programNode3 = programNodeFromAnchorV01(program);
  const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV01);
  return (0, import_nodes41.rootNode)(programNode3, additionalProgramNodes);
}

// src/index.ts
function rootNodeFromAnchor(idl) {
  return (0, import_visitors2.visit)(rootNodeFromAnchorWithoutDefaultVisitor(idl), defaultVisitor());
}
function rootNodeFromAnchorWithoutDefaultVisitor(idl) {
  if (idl.metadata?.spec === "0.1.0") {
    return rootNodeFromAnchorV01(idl);
  }
  return rootNodeFromAnchorV00(idl);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  accountNodeFromAnchorV00,
  accountNodeFromAnchorV01,
  arrayTypeNodeFromAnchorV00,
  arrayTypeNodeFromAnchorV01,
  defaultVisitor,
  definedTypeNodeFromAnchorV00,
  definedTypeNodeFromAnchorV01,
  enumEmptyVariantTypeNodeFromAnchorV00,
  enumEmptyVariantTypeNodeFromAnchorV01,
  enumStructVariantTypeNodeFromAnchorV00,
  enumStructVariantTypeNodeFromAnchorV01,
  enumTupleVariantTypeNodeFromAnchorV00,
  enumTupleVariantTypeNodeFromAnchorV01,
  enumTypeNodeFromAnchorV00,
  enumTypeNodeFromAnchorV01,
  errorNodeFromAnchorV00,
  errorNodeFromAnchorV01,
  extractGenerics,
  getAnchorAccountDiscriminatorV00,
  getAnchorDiscriminatorV01,
  getAnchorInstructionDiscriminatorV00,
  instructionAccountNodeFromAnchorV00,
  instructionAccountNodeFromAnchorV01,
  instructionAccountNodesFromAnchorV00,
  instructionAccountNodesFromAnchorV01,
  instructionArgumentNodeFromAnchorV00,
  instructionArgumentNodeFromAnchorV01,
  instructionNodeFromAnchorV00,
  instructionNodeFromAnchorV01,
  mapTypeNodeFromAnchorV00,
  optionTypeNodeFromAnchorV00,
  optionTypeNodeFromAnchorV01,
  pdaNodeFromAnchorV00,
  programNodeFromAnchorV00,
  programNodeFromAnchorV01,
  rootNodeFromAnchor,
  rootNodeFromAnchorV00,
  rootNodeFromAnchorV01,
  rootNodeFromAnchorWithoutDefaultVisitor,
  setTypeNodeFromAnchorV00,
  structFieldTypeNodeFromAnchorV00,
  structFieldTypeNodeFromAnchorV01,
  structTypeNodeFromAnchorV00,
  structTypeNodeFromAnchorV01,
  tupleTypeNodeFromAnchorV00,
  tupleTypeNodeFromAnchorV01,
  typeNodeFromAnchorV00,
  typeNodeFromAnchorV01,
  unwrapGenericTypeFromAnchorV01
});
//# sourceMappingURL=index.node.cjs.map